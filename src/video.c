#include "video.h"
#include "data.h" // for swap
#include "fonts.h"
#include <raylib.h>
#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdio.h>
#include <stdbool.h>

Image bufferImage;
pthread_t thread = 0;
pthread_mutex_t termination_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t video_mutex = PTHREAD_MUTEX_INITIALIZER;
bool dirty = false;

// charset

byte charset[][8] = {
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, //  
	{ 0x10,0x10,0x10,0x10,0x10,0x00,0x10,0x00 }, // !
	{ 0x24,0x6c,0x00,0x00,0x00,0x00,0x00,0x00 }, // "
	{ 0x00,0x24,0x7e,0x24,0x24,0x7e,0x24,0x00 }, // #
	{ 0x00,0x10,0x3c,0x40,0x7c,0x04,0x78,0x10 }, // $
	{ 0x60,0xa4,0xc8,0x10,0x26,0x4a,0x0c,0x00 }, // %
	{ 0x38,0x44,0x28,0x10,0x2a,0x44,0x3a,0x00 }, // &
	{ 0x08,0x18,0x00,0x00,0x00,0x00,0x00,0x00 }, // '
	{ 0x08,0x10,0x20,0x20,0x20,0x10,0x08,0x00 }, // (
	{ 0x20,0x10,0x08,0x08,0x08,0x10,0x20,0x00 }, // )
	{ 0x00,0x10,0x54,0x38,0x54,0x10,0x00,0x00 }, // *
	{ 0x00,0x10,0x10,0x7c,0x10,0x10,0x00,0x00 }, // +
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x30 }, // ,
	{ 0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00 }, // -
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00 }, // .
	{ 0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00 }, // /
	{ 0x38,0x44,0x44,0x44,0x44,0x44,0x38,0x00 }, // 0
	{ 0x70,0x10,0x10,0x10,0x14,0x14,0x7c,0x00 }, // 1
	{ 0x78,0x04,0x04,0x78,0x40,0x40,0x7c,0x00 }, // 2
	{ 0x78,0x04,0x04,0x38,0x04,0x04,0x78,0x00 }, // 3
	{ 0x40,0x48,0x48,0x48,0x7c,0x08,0x08,0x00 }, // 4
	{ 0x3c,0x20,0x20,0x38,0x04,0x44,0x38,0x00 }, // 5
	{ 0x60,0x40,0x40,0x78,0x44,0x44,0x78,0x00 }, // 6
	{ 0x7c,0x44,0x04,0x08,0x10,0x10,0x10,0x00 }, // 7
	{ 0x10,0x28,0x28,0x38,0x44,0x44,0x38,0x00 }, // 8
	{ 0x3c,0x44,0x44,0x3c,0x04,0x04,0x0c,0x00 }, // 9
	{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00 }, // :
	{ 0x00,0x18,0x18,0x00,0x00,0x18,0x08,0x08 }, // ;
	{ 0x00,0x0c,0x10,0x60,0x10,0x0c,0x00,0x00 }, // <
	{ 0x00,0x00,0x7e,0x00,0x7e,0x00,0x00,0x00 }, // =
	{ 0x00,0x30,0x08,0x06,0x08,0x30,0x00,0x00 }, // >
	{ 0x18,0x24,0x48,0x10,0x10,0x00,0x10,0x00 }, // ?
	{ 0x7c,0x82,0xba,0xaa,0xbe,0x80,0x7c,0x00 }, // @
	{ 0x18,0x18,0x24,0x24,0x3c,0x42,0x42,0x00 }, // A
	{ 0x78,0x44,0x44,0x78,0x44,0x44,0x78,0x00 }, // B
	{ 0x1c,0x20,0x20,0x40,0x20,0x20,0x1c,0x00 }, // C
	{ 0x78,0x24,0x24,0x22,0x24,0x24,0x78,0x00 }, // D
	{ 0x7c,0x40,0x40,0x70,0x40,0x40,0x7c,0x00 }, // E
	{ 0x7c,0x40,0x78,0x40,0x40,0x40,0x40,0x00 }, // F
	{ 0x1c,0x20,0x40,0x40,0x4c,0x44,0x38,0x00 }, // G
	{ 0x44,0x44,0x44,0x7c,0x44,0x44,0x44,0x00 }, // H
	{ 0x7c,0x10,0x10,0x10,0x10,0x10,0x7c,0x00 }, // I
	{ 0x04,0x04,0x04,0x04,0x24,0x24,0x18,0x00 }, // J
	{ 0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x00 }, // K
	{ 0x40,0x40,0x40,0x40,0x40,0x40,0x7c,0x00 }, // L
	{ 0x66,0x7e,0x5a,0x42,0x42,0x42,0x42,0x00 }, // M
	{ 0x64,0x64,0x54,0x54,0x4c,0x4c,0x44,0x00 }, // N
	{ 0x18,0x24,0x42,0x42,0x42,0x24,0x18,0x00 }, // O
	{ 0x78,0x44,0x44,0x78,0x40,0x40,0x40,0x00 }, // P
	{ 0x0c,0x12,0x22,0x42,0x54,0x48,0x36,0x00 }, // Q
	{ 0x78,0x44,0x78,0x60,0x50,0x48,0x44,0x00 }, // R
	{ 0x38,0x44,0x20,0x10,0x08,0x44,0x38,0x00 }, // S
	{ 0x7c,0x54,0x10,0x10,0x10,0x10,0x10,0x00 }, // T
	{ 0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x00 }, // U
	{ 0x44,0x44,0x44,0x28,0x28,0x10,0x10,0x00 }, // V
	{ 0x44,0x44,0x44,0x54,0x54,0x54,0x28,0x00 }, // W
	{ 0x44,0x44,0x28,0x10,0x28,0x44,0x44,0x00 }, // X
	{ 0x44,0x44,0x28,0x10,0x10,0x10,0x10,0x00 }, // Y
	{ 0x7c,0x04,0x08,0x10,0x20,0x40,0x7c,0x00 }, // Z
	{ 0x3c,0x20,0x20,0x20,0x20,0x20,0x3c,0x00 }, // [
	{ 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x00 }, // rev. slash
	{ 0x3c,0x04,0x04,0x04,0x04,0x04,0x3c,0x00 }, // ]
	{ 0x10,0x10,0x38,0x44,0x00,0x00,0x00,0x00 }, // ^
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff }, // _
	{ 0x18,0x10,0x10,0x7c,0x20,0x20,0x7c,0x00 }, // £
	{ 0x00,0x00,0x1c,0x02,0x3e,0x42,0x3e,0x00 }, // a
	{ 0x40,0x40,0x7c,0x42,0x42,0x42,0x7c,0x00 }, // b
	{ 0x00,0x00,0x3e,0x40,0x40,0x40,0x3e,0x00 }, // c
	{ 0x02,0x02,0x3e,0x42,0x42,0x42,0x3e,0x00 }, // d
	{ 0x00,0x00,0x3c,0x42,0x7e,0x40,0x3e,0x00 }, // e
	{ 0x0e,0x10,0x38,0x10,0x10,0x10,0x10,0x00 }, // f
	{ 0x00,0x00,0x3e,0x42,0x42,0x3e,0x02,0x7c }, // g
	{ 0x40,0x40,0x5c,0x62,0x42,0x42,0x42,0x00 }, // h
	{ 0x18,0x00,0x38,0x08,0x08,0x08,0x3e,0x00 }, // i
	{ 0x06,0x00,0x0e,0x02,0x02,0x02,0x22,0x1c }, // j
	{ 0x40,0x40,0x44,0x48,0x70,0x48,0x44,0x00 }, // k
	{ 0x38,0x08,0x08,0x08,0x08,0x08,0x3e,0x00 }, // l
	{ 0x00,0x00,0x68,0x54,0x54,0x54,0x54,0x00 }, // m
	{ 0x00,0x00,0x5c,0x62,0x42,0x42,0x42,0x00 }, // n
	{ 0x00,0x00,0x3c,0x42,0x42,0x42,0x3c,0x00 }, // o
	{ 0x00,0x00,0x7c,0x42,0x42,0x7c,0x40,0x40 }, // p
	{ 0x00,0x00,0x3e,0x42,0x42,0x3e,0x02,0x02 }, // q
	{ 0x00,0x00,0x5c,0x62,0x40,0x40,0x40,0x00 }, // r
	{ 0x00,0x00,0x3e,0x40,0x3c,0x02,0x7c,0x00 }, // s
	{ 0x20,0x20,0x78,0x20,0x20,0x22,0x1c,0x00 }, // t
	{ 0x00,0x00,0x42,0x42,0x42,0x46,0x3a,0x00 }, // u
	{ 0x00,0x00,0x42,0x42,0x24,0x24,0x18,0x00 }, // v
	{ 0x00,0x00,0x44,0x44,0x54,0x54,0x28,0x00 }, // w
	{ 0x00,0x00,0x42,0x24,0x18,0x24,0x42,0x00 }, // x
	{ 0x00,0x00,0x42,0x42,0x24,0x18,0x10,0x60 }, // y
	{ 0x00,0x00,0x7e,0x04,0x18,0x20,0x7e,0x00 }, // z
	{ 0x0e,0x10,0x10,0x70,0x10,0x10,0x0e,0x00 }, // {
	{ 0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00 }, // |
	{ 0x70,0x08,0x08,0x0e,0x08,0x08,0x70,0x00 }, // }
	{ 0x34,0x54,0x58,0x00,0x00,0x00,0x00,0x00 }, // ~
	{ 0x3c,0x5a,0xa5,0xa1,0xa5,0x99,0x42,0x3c } // ©
};


// buffers
byte video[192][256 >> 3];
Attrib attribs[24][32];
Color zxcolors[2][8] = {
    {
        BLACK,
        {0, 0, 216, 255},
        {216, 0, 0, 255},
        {216, 0, 216, 255},
        {0, 216, 0, 255},
        {0, 216, 216, 255},
        {216, 216, 0, 255},
        {216, 216, 216, 255}
    },
    {
        BLACK,
        {0, 0, 255, 255},
        {255, 0, 0, 255},
        {255, 0, 255, 255},
        {0, 255, 0, 255},
        {0, 255, 255, 255},
        {255, 255, 0, 255},
        WHITE
    }
};


int getMillis() {
    clock_t t = clock();
    return (t * 1000) / CLOCKS_PER_SEC;
}

void swapColors(Color* one, Color* two){
    Color tmp = *one;
    *one = *two;
    *two = tmp;
}

void drawByte(byte col, byte row, Color ink, Color paper) {
    byte line = video[row][col];
	//printf("print %d - %d\n", row, col);
    for(byte b = 0; b < 8; ++b) {
        ImageDrawPixel(&bufferImage, col * 8 + b, row, (line & 0x80 ? ink : paper) );
        line <<= 1;
    }
}

typedef struct {
    Color ink, paper;
} Colors;

Colors getAttrib(byte col, byte row) {
    Attrib curr = attribs[row][col];
    Colors ret;
    ret.ink = zxcolors[curr.bright][curr.ink];
    ret.paper = zxcolors[curr.bright][curr.paper];
    if(curr.flash && ((getMillis()/500) & 1)) {
        swapColors(&ret.ink, &ret.paper);
    }
    return ret;
}

void copyBuffer() {
    for(byte lines = 0; lines < 24; ++lines) {
        for(byte cols = 0; cols < 32; ++cols) {
            Colors colors = getAttrib(cols, lines);
            for(byte subline = 0; subline < 8; ++subline) {
                drawByte(cols, lines * 8 + subline, colors.ink, colors.paper);
            }
        }
    }
    
}

void initScreen(void) {
    InitWindow(800, 600, "jetpac");
    bufferImage = GenImageColor(256, 192, BLACK);
}
void renderLoop(void){
	Texture2D tex = LoadTextureFromImage(bufferImage);
    while(!WindowShouldClose()) {
		pthread_mutex_lock(&video_mutex);
		if(dirty) {
			copyBuffer();
			UpdateTexture(tex, bufferImage.data);
			dirty = false;
		}
		pthread_mutex_unlock(&video_mutex);
        BeginDrawing();
            DrawTexturePro(
                tex,
                (Rectangle){.x = 0, .y = 0, .width = tex.width, .height = tex.height},
                (Rectangle){.x = 0, .y = 0, .width = GetScreenWidth(), .height = GetScreenHeight()},
                (Vector2){0, 0},
                0,
                WHITE
            );
        EndDrawing();
    }
	UnloadTexture(tex);
}
void terminateScreen(void){
	if(thread) {
		pthread_mutex_lock(&termination_mutex);
		pthread_join(thread, NULL);
		pthread_mutex_unlock(&termination_mutex);
	}
    pthread_mutex_destroy(&video_mutex);
    pthread_mutex_destroy(&termination_mutex);
    UnloadImage(bufferImage);
}

void checkTermination(void) {
    if(pthread_mutex_trylock(&termination_mutex) != 0) {
        pthread_exit(NULL);
    } else 
        pthread_mutex_unlock(&termination_mutex);
}

void clearScreen(Attrib attrib){
	pthread_mutex_lock(&video_mutex);
    bzero(video, sizeof(video));
    memset(attribs, attrib.attrib, sizeof(attribs));
	pthread_mutex_unlock(&video_mutex);
}

void do_SquareOut(Coords coords, const byte* ptr) { //unlocked version
	for(int i = 0; i < 8; ++i) {
		video[coords.y + i][coords.x / 8] = ptr[i];
	}
	dirty = true;
}
void do_SquareOutAttrib(Coords coords, const byte* ptr, Attrib attr) {
	attribs[coords.y / 8][coords.x / 8].attrib = attr.attrib;
	do_SquareOut(coords, ptr);
}

void textOut(Coords coords, const char* ptr, Attrib attr){
    byte x = coords.x;
    byte y = coords.y;
    pthread_mutex_lock(&video_mutex);
    while(*ptr) {
        byte* ch = &charset[*ptr - 32][0];
        do_SquareOutAttrib((Coords){.x = x, .y = y}, ch, attr);
        ++ptr;
		x += 8;
    }
    pthread_mutex_unlock(&video_mutex);
}

void setAttrib(byte col, byte row, Attrib attr) {
    pthread_mutex_lock(&video_mutex);
    attribs[row][col].attrib = attr.attrib;
    pthread_mutex_unlock(&video_mutex);
}

void squareOut(Coords coords, const byte* ptr, Attrib attr) {
	pthread_mutex_lock(&video_mutex);
	do_SquareOutAttrib(coords, ptr, attr);
	pthread_mutex_unlock(&video_mutex);
}