#include "video.h"
#include "data.h" // for swap
#include <raylib.h>
#ifdef WIN32
#include "wingotcha.h"
#else
#include <pthread.h>
#include <unistd.h>
#include <stdatomic.h>
#endif
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdio.h>
#include <stdbool.h>

#include <assert.h>

Image bufferImage;
pthread_t thread = 0;
atomic_bool terminate;
pthread_mutex_t video_mutex = PTHREAD_MUTEX_INITIALIZER;
atomic_uint_least16_t gameTime = 0;
atomic_bool interruptsEnabled;


// charset

byte charset[][8] = {
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, //  
	{ 0x10,0x10,0x10,0x10,0x10,0x00,0x10,0x00 }, // !
	{ 0x24,0x6c,0x00,0x00,0x00,0x00,0x00,0x00 }, // "
	{ 0x00,0x24,0x7e,0x24,0x24,0x7e,0x24,0x00 }, // #
	{ 0x00,0x10,0x3c,0x40,0x7c,0x04,0x78,0x10 }, // $
	{ 0x60,0xa4,0xc8,0x10,0x26,0x4a,0x0c,0x00 }, // %
	{ 0x38,0x44,0x28,0x10,0x2a,0x44,0x3a,0x00 }, // &
	{ 0x08,0x18,0x00,0x00,0x00,0x00,0x00,0x00 }, // '
	{ 0x08,0x10,0x20,0x20,0x20,0x10,0x08,0x00 }, // (
	{ 0x20,0x10,0x08,0x08,0x08,0x10,0x20,0x00 }, // )
	{ 0x00,0x10,0x54,0x38,0x54,0x10,0x00,0x00 }, // *
	{ 0x00,0x10,0x10,0x7c,0x10,0x10,0x00,0x00 }, // +
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x30 }, // ,
	{ 0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00 }, // -
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00 }, // .
	{ 0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00 }, // /
	{ 0x38,0x44,0x44,0x44,0x44,0x44,0x38,0x00 }, // 0
	{ 0x70,0x10,0x10,0x10,0x14,0x14,0x7c,0x00 }, // 1
	{ 0x78,0x04,0x04,0x78,0x40,0x40,0x7c,0x00 }, // 2
	{ 0x78,0x04,0x04,0x38,0x04,0x04,0x78,0x00 }, // 3
	{ 0x40,0x48,0x48,0x48,0x7c,0x08,0x08,0x00 }, // 4
	{ 0x3c,0x20,0x20,0x38,0x04,0x44,0x38,0x00 }, // 5
	{ 0x60,0x40,0x40,0x78,0x44,0x44,0x78,0x00 }, // 6
	{ 0x7c,0x44,0x04,0x08,0x10,0x10,0x10,0x00 }, // 7
	{ 0x10,0x28,0x28,0x38,0x44,0x44,0x38,0x00 }, // 8
	{ 0x3c,0x44,0x44,0x3c,0x04,0x04,0x0c,0x00 }, // 9
	{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00 }, // :
	{ 0x00,0x18,0x18,0x00,0x00,0x18,0x08,0x08 }, // ;
	{ 0x00,0x0c,0x10,0x60,0x10,0x0c,0x00,0x00 }, // <
	{ 0x00,0x00,0x7e,0x00,0x7e,0x00,0x00,0x00 }, // =
	{ 0x00,0x30,0x08,0x06,0x08,0x30,0x00,0x00 }, // >
	{ 0x18,0x24,0x48,0x10,0x10,0x00,0x10,0x00 }, // ?
	{ 0x7c,0x82,0xba,0xaa,0xbe,0x80,0x7c,0x00 }, // @
	{ 0x18,0x18,0x24,0x24,0x3c,0x42,0x42,0x00 }, // A
	{ 0x78,0x44,0x44,0x78,0x44,0x44,0x78,0x00 }, // B
	{ 0x1c,0x20,0x20,0x40,0x20,0x20,0x1c,0x00 }, // C
	{ 0x78,0x24,0x24,0x22,0x24,0x24,0x78,0x00 }, // D
	{ 0x7c,0x40,0x40,0x70,0x40,0x40,0x7c,0x00 }, // E
	{ 0x7c,0x40,0x78,0x40,0x40,0x40,0x40,0x00 }, // F
	{ 0x1c,0x20,0x40,0x40,0x4c,0x44,0x38,0x00 }, // G
	{ 0x44,0x44,0x44,0x7c,0x44,0x44,0x44,0x00 }, // H
	{ 0x7c,0x10,0x10,0x10,0x10,0x10,0x7c,0x00 }, // I
	{ 0x04,0x04,0x04,0x04,0x24,0x24,0x18,0x00 }, // J
	{ 0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x00 }, // K
	{ 0x40,0x40,0x40,0x40,0x40,0x40,0x7c,0x00 }, // L
	{ 0x66,0x7e,0x5a,0x42,0x42,0x42,0x42,0x00 }, // M
	{ 0x64,0x64,0x54,0x54,0x4c,0x4c,0x44,0x00 }, // N
	{ 0x18,0x24,0x42,0x42,0x42,0x24,0x18,0x00 }, // O
	{ 0x78,0x44,0x44,0x78,0x40,0x40,0x40,0x00 }, // P
	{ 0x0c,0x12,0x22,0x42,0x54,0x48,0x36,0x00 }, // Q
	{ 0x78,0x44,0x78,0x60,0x50,0x48,0x44,0x00 }, // R
	{ 0x38,0x44,0x20,0x10,0x08,0x44,0x38,0x00 }, // S
	{ 0x7c,0x54,0x10,0x10,0x10,0x10,0x10,0x00 }, // T
	{ 0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x00 }, // U
	{ 0x44,0x44,0x44,0x28,0x28,0x10,0x10,0x00 }, // V
	{ 0x44,0x44,0x44,0x54,0x54,0x54,0x28,0x00 }, // W
	{ 0x44,0x44,0x28,0x10,0x28,0x44,0x44,0x00 }, // X
	{ 0x44,0x44,0x28,0x10,0x10,0x10,0x10,0x00 }, // Y
	{ 0x7c,0x04,0x08,0x10,0x20,0x40,0x7c,0x00 }, // Z
	{ 0x3c,0x20,0x20,0x20,0x20,0x20,0x3c,0x00 }, // [
	{ 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x00 }, // rev. slash
	{ 0x3c,0x04,0x04,0x04,0x04,0x04,0x3c,0x00 }, // ]
	{ 0x10,0x10,0x38,0x44,0x00,0x00,0x00,0x00 }, // ^
	{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff }, // _
	{ 0x18,0x10,0x10,0x7c,0x20,0x20,0x7c,0x00 }, // £
	{ 0x00,0x00,0x1c,0x02,0x3e,0x42,0x3e,0x00 }, // a
	{ 0x40,0x40,0x7c,0x42,0x42,0x42,0x7c,0x00 }, // b
	{ 0x00,0x00,0x3e,0x40,0x40,0x40,0x3e,0x00 }, // c
	{ 0x02,0x02,0x3e,0x42,0x42,0x42,0x3e,0x00 }, // d
	{ 0x00,0x00,0x3c,0x42,0x7e,0x40,0x3e,0x00 }, // e
	{ 0x0e,0x10,0x38,0x10,0x10,0x10,0x10,0x00 }, // f
	{ 0x00,0x00,0x3e,0x42,0x42,0x3e,0x02,0x7c }, // g
	{ 0x40,0x40,0x5c,0x62,0x42,0x42,0x42,0x00 }, // h
	{ 0x18,0x00,0x38,0x08,0x08,0x08,0x3e,0x00 }, // i
	{ 0x06,0x00,0x0e,0x02,0x02,0x02,0x22,0x1c }, // j
	{ 0x40,0x40,0x44,0x48,0x70,0x48,0x44,0x00 }, // k
	{ 0x38,0x08,0x08,0x08,0x08,0x08,0x3e,0x00 }, // l
	{ 0x00,0x00,0x68,0x54,0x54,0x54,0x54,0x00 }, // m
	{ 0x00,0x00,0x5c,0x62,0x42,0x42,0x42,0x00 }, // n
	{ 0x00,0x00,0x3c,0x42,0x42,0x42,0x3c,0x00 }, // o
	{ 0x00,0x00,0x7c,0x42,0x42,0x7c,0x40,0x40 }, // p
	{ 0x00,0x00,0x3e,0x42,0x42,0x3e,0x02,0x02 }, // q
	{ 0x00,0x00,0x5c,0x62,0x40,0x40,0x40,0x00 }, // r
	{ 0x00,0x00,0x3e,0x40,0x3c,0x02,0x7c,0x00 }, // s
	{ 0x20,0x20,0x78,0x20,0x20,0x22,0x1c,0x00 }, // t
	{ 0x00,0x00,0x42,0x42,0x42,0x46,0x3a,0x00 }, // u
	{ 0x00,0x00,0x42,0x42,0x24,0x24,0x18,0x00 }, // v
	{ 0x00,0x00,0x44,0x44,0x54,0x54,0x28,0x00 }, // w
	{ 0x00,0x00,0x42,0x24,0x18,0x24,0x42,0x00 }, // x
	{ 0x00,0x00,0x42,0x42,0x24,0x18,0x10,0x60 }, // y
	{ 0x00,0x00,0x7e,0x04,0x18,0x20,0x7e,0x00 }, // z
	{ 0x0e,0x10,0x10,0x70,0x10,0x10,0x0e,0x00 }, // {
	{ 0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00 }, // |
	{ 0x70,0x08,0x08,0x0e,0x08,0x08,0x70,0x00 }, // }
	{ 0x34,0x54,0x58,0x00,0x00,0x00,0x00,0x00 }, // ~
	{ 0x3c,0x5a,0xa5,0xa1,0xa5,0x99,0x42,0x3c } // ©
};


// buffers
byte video[192][32];
Attrib attribs[24][32];
Color zxcolors[2][8] = {
    {
		{0, 0, 0, 255},
        {0, 0, 216, 255},
        {216, 0, 0, 255},
        {216, 0, 216, 255},
        {0, 216, 0, 255},
        {0, 216, 216, 255},
        {216, 216, 0, 255},
        {216, 216, 216, 255}
    },
    {
		{0, 0, 0, 255},
        {0, 0, 255, 255},
        {255, 0, 0, 255},
        {255, 0, 255, 255},
        {0, 255, 0, 255},
        {0, 255, 255, 255},
        {255, 255, 0, 255},
		{255, 255, 255, 255}
    }
};


int getMillis() {
    clock_t t = clock();
    return (t * 1000) / CLOCKS_PER_SEC;
}    	

void swapColors(Color* one, Color* two){
    Color tmp = *one;
    *one = *two;
    *two = tmp;
}

void lockVideo() {
	pthread_mutex_lock(&video_mutex);
}
void unlockVideo() {
	pthread_mutex_unlock(&video_mutex);
}

static inline void writeVideo(byte xcol, byte yline, byte what) {
	assert(xcol < 32 && yline < 192);
	video[yline][xcol] = what;
}
static inline void writeAttrib(byte xcol, byte yrow, Attrib what) {
	assert(xcol < 32 && yrow < 24);
	attribs[yrow][xcol] = what;
}

void drawByte(byte col, byte row, Color ink, Color paper) {
    byte line = video[row][col];
	//printf("print %d - %d\n", row, col);
    for(byte b = 0; b < 8; ++b) {
        ImageDrawPixel(&bufferImage, col * 8 + b, row, (line & 0x80 ? ink : paper) );
        line <<= 1;
    }
}

typedef struct {
    Color ink, paper;
} Colors;

static Colors internal_getAttrib(byte col, byte row) {
    Attrib curr = attribs[row][col];
    Colors ret;
    ret.ink = zxcolors[curr.bright][curr.ink];
    ret.paper = zxcolors[curr.bright][curr.paper];
    if(curr.flash && ((getMillis()/320) & 1)) {
        swapColors(&ret.ink, &ret.paper);
    }
    return ret;
}

void copyBuffer() {
    for(byte lines = 0; lines < 24; ++lines) {
        for(byte cols = 0; cols < 32; ++cols) {
            Colors colors = internal_getAttrib(cols, lines);
            for(byte subline = 0; subline < 8; ++subline) {
                drawByte(cols, lines * 8 + subline, colors.ink, colors.paper);
            }
        }
    }
}

void initScreen(void) {
	atomic_store(&interruptsEnabled, true);
    InitWindow(1024, 768, "jetpac");
    bufferImage = GenImageColor(256, 192, BLACK);
#ifdef WIN32
	pthread_mutex_init(&video_mutex);
#endif
}

typedef struct {
	int x;
	int y;
	int w;
	int h;
} WinSize;

WinSize getWinSize() {
	if (!IsWindowFullscreen()) {
		return (WinSize) { .x = 0, .y = 0, .w = GetRenderWidth(), .h = GetRenderHeight() };
	}
	else {
		int h = GetRenderHeight();
		int w = GetRenderWidth();
		if (h * 4 / 3 > w) {
			int offs = w * 3 / 4;
			return (WinSize) { .x = 0, .y = (h - offs) / 2, .w = w, .h = offs };
		}
		else {
			int offs = h * 4 / 3;
			return (WinSize) { .x = (w - offs) / 2, .y = 0, .w = offs, .h = h };
		}
	}
}

void renderLoop(void){
	Texture2D tex = LoadTextureFromImage(bufferImage);
    int millis = 0;
	WinSize winsize = getWinSize();
	while(!WindowShouldClose()) {
		int newmillis = getMillis();
		if(atomic_load(&interruptsEnabled)) {
			if(newmillis - millis > 20) {
				atomic_fetch_add(&gameTime, 1);
				millis = newmillis;
			}
		} else {
			millis = newmillis;
		}
		lockVideo();
			copyBuffer();
			UpdateTexture(tex, bufferImage.data);
		unlockVideo();
		if (IsKeyPressed(KEY_F1)) {
			ToggleFullscreen();
			winsize = getWinSize();
		}
        BeginDrawing();
			ClearBackground(BLACK);
            DrawTexturePro(
                tex,
                (Rectangle){.x = 0, .y = 0, .width = tex.width, .height = tex.height},
                (Rectangle){.x = winsize.x, .y = winsize.y, .width = winsize.w, .height = winsize.h},
                (Vector2){0, 0},
                0,
                WHITE
            );
        EndDrawing();
    }
	UnloadTexture(tex);
}
void terminateScreen(void){
	atomic_store(&terminate, 1);
	if(thread)
		pthread_join(thread, NULL);
    pthread_mutex_destroy(&video_mutex);
    UnloadImage(bufferImage);
}

void checkTermination(void) {
    if(atomic_load(&terminate) == 1) {
        pthread_exit(NULL);
	}
}

void clearScreen(Attrib attrib){
	lockVideo();
    bzero(video, sizeof(video));
    memset(attribs, attrib.attrib, sizeof(attribs));
	unlockVideo();
}

void do_SquareOut(Coords coords, const byte* ptr) { //unlocked version
	for(int i = 0; i < 8; ++i) {
		writeVideo(coords.x /8, coords.y + i, ptr[i]);
	}
}
void do_SquareOutAttrib(Coords coords, const byte* ptr, Attrib attr) {
	writeAttrib(coords.x / 8, coords.y / 8, attr);
	do_SquareOut(coords, ptr);
}

void textOutAttrib(Coords coords, const char* ptr, Attrib attr){
    byte x = coords.x;
    byte y = coords.y;
    lockVideo();
    while(*ptr) {
        byte* ch = &charset[*ptr - 32][0];
        do_SquareOutAttrib((Coords){.x = x, .y = y}, ch, attr);
        ++ptr;
		x += 8;
    }
    unlockVideo();
}

void textOut(Coords coords, const char* ptr){
    byte x = coords.x;
    byte y = coords.y;
    lockVideo();
    while(*ptr) {
        byte* ch = &charset[*ptr - 32][0];
        do_SquareOut((Coords){.x = x, .y = y}, ch);
        ++ptr;
		x += 8;
    }
    unlockVideo();
}

void setAttrib(byte col, byte row, Attrib attr) {
    lockVideo();
	writeAttrib(col, row, attr);
    unlockVideo();
}

Attrib getAttrib(byte col, byte row) {
	lockVideo();
	Attrib ret = attribs[row][col];
	unlockVideo();
	return ret;
}

void squareOut(Coords coords, const byte* ptr, Attrib attr) {
	lockVideo();
	do_SquareOutAttrib(coords, ptr, attr);
	unlockVideo();
}

void byteOutNoLock(Coords coords, const byte byte1, enum Operator op) {
byte b = video[coords.y][coords.x / 8];
	switch(op) {
		case EQUAL:
			b = byte1;
			break;
		case OR:
			b |= byte1;
			break;
		case AND:
			b &= byte1;
			break;
		case XOR:
			b ^= byte1;
			break;
		default:
			assert(0);
			break;
	}
	//printf("Writing %x at %d %d\n", b, coords.x, coords.y);
	writeVideo(coords.x / 8, coords.y, b);
}

void byteOut(Coords coords, const byte byte1, enum Operator op) {
	assert(coords.y < 192);
	lockVideo();
	byteOutNoLock(coords, byte1, op);
	unlockVideo();
}

byte getVideoByte(Coords coords) {
	lockVideo();
	byte b = video[coords.y][coords.x / 8];
	unlockVideo();
	return b;
}


word getGameTime(){
	word ret = atomic_load(&gameTime);
	return ret;
}
void resetGameTime() {
	atomic_store(&gameTime, 0);
}

void playSound(byte pitch, byte duration){

}

void gameSleep(int micro) {
	usleep(micro);
}

void ei() {
	atomic_store(&interruptsEnabled, true);
}
void di() {
	atomic_store(&interruptsEnabled, false);
}